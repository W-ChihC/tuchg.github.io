{"meta":{"title":"tuchg 的个人博客","subtitle":"","description":"","author":"tuchg","url":"https://tuchg.github.io","root":"/"},"pages":[{"title":"","date":"2020-05-22T06:22:07.246Z","updated":"2020-05-21T11:23:46.836Z","comments":false,"path":"about/index.html","permalink":"https://tuchg.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-22T06:22:07.247Z","updated":"2020-05-21T11:23:36.906Z","comments":false,"path":"categories/index.html","permalink":"https://tuchg.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-22T06:22:07.246Z","updated":"2020-05-21T11:24:05.241Z","comments":true,"path":"links/index.html","permalink":"https://tuchg.github.io/links/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-22T06:22:07.244Z","updated":"2020-05-21T11:24:19.455Z","comments":false,"path":"repository/index.html","permalink":"https://tuchg.github.io/repository/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-22T06:22:07.246Z","updated":"2020-05-21T11:24:39.744Z","comments":false,"path":"tags/index.html","permalink":"https://tuchg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vert.x 踩坑记：在Vert.x中使用ElasticSearch进行高亮等高级查询协程化","slug":"coroutines-Vert.x-ElasticSearch-advanced-query","date":"2020-05-23T06:10:00.000Z","updated":"2020-07-05T03:34:42.975Z","comments":true,"path":"2020/05/23/coroutines-Vert.x-ElasticSearch-advanced-query/","link":"","permalink":"https://tuchg.github.io/2020/05/23/coroutines-Vert.x-ElasticSearch-advanced-query/","excerpt":"1. 测试环境Vert.x : 4.0.0-milestone4kotlin-coroutines :1.3.20jackson-databind : 2.11.0Vert.x 内置 jackson未提供映射到POJO实体的ObjectMapper实现ElasticSearch : 6.8Elasticsearch-client (for vert.x) : 0.2 - ec 6.7.0","text":"1. 测试环境Vert.x : 4.0.0-milestone4kotlin-coroutines :1.3.20jackson-databind : 2.11.0Vert.x 内置 jackson未提供映射到POJO实体的ObjectMapper实现ElasticSearch : 6.8Elasticsearch-client (for vert.x) : 0.2 - ec 6.7.0👇贴出 Gradle(kotlin) 的关键依赖,Maven同理123456789101112131415161718192021222324//.... /*** 仅贴出所需部分依赖,余下需自行在官网利用 starter 生成*/ext &#123; vertxVersion = '4.0.0-milestone4'&#125;dependencies &#123; //objectMapper实现 implementation \"com.fasterxml.jackson.core:jackson-databind:2.11.0\" //es vert.x 第三方兼容客户端 implementation \"io.reactiverse:elasticsearch-client:0.2-ec6.7.0\" //kotlin implementation \"io.vertx:vertx-lang-kotlin-coroutines:$vertxVersion\" implementation \"io.vertx:vertx-lang-kotlin:$vertxVersion\" // .....&#125;//.....2. 初始化Es客户端io.reactiverse:elasticsearch-client 在 RestHighLevelClient 基础上将异步响应接口简单封装了一层 Vert.x 范的AsyncResult，故而迁移 RestHighLevelClient下代码仅需将请求发送方法更改为elasticsearch-client封装的相对应方法即可io.reactiverse:elasticsearch-client 的封装实现123456789101112131415161718192021/** * io.reactiverse.elasticsearch.client.RestHighLevelClient */@Override()public void searchAsync(SearchRequest searchRequest, RequestOptions options, Handler&lt;AsyncResult&lt;SearchResponse&gt;&gt; handler) &#123; Context context = vertx.getOrCreateContext(); delegate.searchAsync(searchRequest, options, new ActionListener&lt;SearchResponse&gt;() &#123; @Override public void onResponse(SearchResponse value) &#123; //不阻塞地将异步响应注册到指定Verticle的运行时上下文 context.runOnContext(v -&gt; handler.handle(Future.succeededFuture(value))); &#125; @Override public void onFailure(Exception e) &#123; context.runOnContext(v -&gt; handler.handle(Future.failedFuture(e))); &#125; &#125;); &#125;在 Verticle初始化ES客户端12345678910111213141516class ElasticSearchVerticle : CoroutineVerticle() &#123; private lateinit var client: RestHighLevelClient /** * Verticle 实例启动时的回调方法 */ override suspend fun start() &#123; client = RestHighLevelClient.create( // vertx即当前 Verticle 实例 vertx, RestClient .builder(HttpHost(\"127.0.0.1\", 9200, \"http\")) //所写项目功能单一，故指定唯一 index .setPathPrefix(\"/items/\") ) &#125;&#125;4. 构造查询语句1234567891011121314151617181920212223242526272829//koltin 中实现单例模式的语法糖 companion object &#123; private val logger = LoggerFactory.getLogger(ElasticSearchVerticle::class.java) //高亮 private val highlightBuilder: HighlightBuilder = HighlightBuilder() .preTags(\"&lt;em&gt;\").postTags(\"&lt;/em&gt;\") .field(\"q\") .field(\"o\") &#125; private suspend fun searchByQuestionAndOptionsAwait(qStr: String): List&lt;TestEntity&gt; &#123; if (qStr.length &lt;= 5) throw SecurityException(\"字数过短\") val boolBuilder = QueryBuilders.boolQuery() //多个字段匹配 属性值 must query val matchQueryBuilder = QueryBuilders.multiMatchQuery(qStr, \"q\", \"o\") boolBuilder.must(matchQueryBuilder) val searchSourceBuilder = SearchSourceBuilder() .query(boolBuilder) .size(3) //30分为界 .minScore(30.0f) .highlighter(highlightBuilder) // 协程化 return awaitResult &#123; return@awaitResult mapperHandle(TestEntity::class.java, searchSourceBuilder) &#125; &#125;5. 高亮查询结果映射处理123456789101112131415161718192021222324252627282930313233343536373839//koltin 中实现单例模式的语法糖 companion object &#123; // 字段映射器 private val mapper = ObjectMapper() //允许忽略不存在的字段 .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false) &#125; /** * 映射处理,高亮字段等,映射到实体等 */ private fun &lt;T&gt; mapperHandle( clazz: Class&lt;T&gt;, sourceBuilder: SearchSourceBuilder ) &#123; //发起查询请求 return client.searchAsync(SearchRequest().source(sourceBuilder), RequestOptions.DEFAULT) &#123; if (it.succeeded()) &#123; val searchHits = it.result()?.hits val list = ArrayList&lt;T&gt;() //遍历搜索命中结果 searchHits?.forEach &#123; searchHit -&gt; val source = searchHit.sourceAsMap // fragments 因所写项目功能单一故处理不是很恰当 // 将原本与高亮域对应的原生字段替换为高亮后的结果 source[\"q\"] = searchHit.highlightFields[\"q\"]?.fragments?.get(0)?.toString() ?: source[\"q\"] source[\"o\"] = searchHit.highlightFields[\"o\"]?.fragments?.get(0)?.toString() ?: source[\"o\"] //映射到 pojo list.add( mapper.readValue( mapper.writeValueAsString(source), clazz ) ) &#125; &#125; &#125; &#125;6.执行查询12345678910111213141516// 回调化(未贴出代码)searchByQuestionAndOptionsAwait(\"HelloVert.x\") &#123; if (it.succeeded()) //...成功 it.result() else //...失败 it.cause()&#125;// 协程同步化try&#123; val result= searchByQuestionAndOptionsAwait(\"HelloVert.x\") //...成功&#125;catch(e)&#123; //...失败&#125;然而协程在vert.x中解决Callback Hell问题暂时也并非’银弹’，比如在 eventbus 中充当消费者时会不可避免的出现以下状况12345678vertx.eventBus().localConsumer&lt;String&gt;(this.javaClass.name) &#123; msg -&gt; launch &#123; val x = withContext(Dispatchers.Default) &#123; searchByQuestionAndOptionsAwait(\"HelloVert.x\") &#125; msg.reply(x) &#125; &#125;层层回调，和普通异步回调相比似乎并没有减轻多少压力，且增加了更多心智负担（协程调度器），当然也可以尝试自行协程化封装，期待Vert.x 官方能在后续更新加强对kotlin的支持","categories":[{"name":"后端","slug":"后端","permalink":"https://tuchg.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Vert.x","slug":"Vert-x","permalink":"https://tuchg.github.io/tags/Vert-x/"},{"name":"kotlin","slug":"kotlin","permalink":"https://tuchg.github.io/tags/kotlin/"},{"name":"协程","slug":"协程","permalink":"https://tuchg.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://tuchg.github.io/tags/ElasticSearch/"}]},{"title":"WebFlux 下的 ReactiveElasticSearch 高级查询","slug":"webflux-ReactiveElasticSearch-advanced-query","date":"2020-05-22T12:10:00.000Z","updated":"2020-07-05T03:38:12.394Z","comments":true,"path":"2020/05/22/webflux-ReactiveElasticSearch-advanced-query/","link":"","permalink":"https://tuchg.github.io/2020/05/22/webflux-ReactiveElasticSearch-advanced-query/","excerpt":"非 Reactive 的SpringData-ElasticSearch 可利用ESRepository达到高级查询的目的,但 Reative因支持较晚，目前缺乏 search( criteria ) 等高级查询实现，暂时无法利用 Reacitve-JPA 的 Repository 实现高级查询，很尴尬的鸡肋存在不过好在ReactiveElasticsearchTemplate支持相对较为＂全面＂","text":"非 Reactive 的SpringData-ElasticSearch 可利用ESRepository达到高级查询的目的,但 Reative因支持较晚，目前缺乏 search( criteria ) 等高级查询实现，暂时无法利用 Reacitve-JPA 的 Repository 实现高级查询，很尴尬的鸡肋存在不过好在ReactiveElasticsearchTemplate支持相对较为＂全面＂目的：在reactive 的 webflux 体系下实现 es 查询多字段并高亮查询命中结果了解到 JPA 后遂拉入响应式的依赖，调用接口实现，一顿操作猛如虎．．．然后开心的在IDEA 敲下. 体验 JPA 的魔法多次google，百度相关资料全网无果，被逼无奈那就自己走源码实现吧👩‍🦯1. 解决构造查询丢失条件问题查阅 JPA 相关资料了解到了Template这个相对底层的封装，发现ReactiveElasticsearchTemplate提供了传入查询构造器的 find () 方法通过debug观察其运行流程发现了查询请求前置hook 方法prepareSearchRequest，看到这个 hook 后，问题已经解决了80%12345678910111213141516171819202122// 仅重写 hookclass CustomReactiveESTemplate(client: ReactiveElasticsearchClient?, converter: ElasticsearchConverter?, resultsMapper: ResultsMapper?) : ReactiveElasticsearchTemplate(client, converter, resultsMapper) &#123; //ES 查询前置Hook override fun prepareSearchRequest(request: SearchRequest): SearchRequest &#123; if (request.preference().isNotEmpty()) &#123; val sourceQuery = request.source() // 利用相对来说用不上的(项目功能单一)preference属性存取多字段，实现多字段高亮查询 val fields = request.preference().split(\"#\") //高亮构建器 val highlightBuilder = HighlightBuilder() .preTags(\"&lt;em&gt;\").postTags(\"&lt;/em&gt;\") //遍历解析到的高亮域至高亮构建 fields.forEach &#123; highlightBuilder.field(it) &#125; sourceQuery.highlighter(highlightBuilder) //还原查询 request.preference(\"\") &#125; return super.prepareSearchRequest(request) &#125;&#125;你也许会说既然允许自己构造查询了，何必大费周章还带有破坏性地写hook 函数，直接构造高级查询传入不行吗？我一开始也这样想的且这样做的，不过行不通，位于ReactiveElasticsearchTemplate的find() 会调用到buildSearchRequest()，该函数只读取特定查询，高亮查询并不在此列，只能自行通过预置在buildSearchRequest()之后的 hook 函数，加入高级查询2. 向 SpringBoot注入自定义hook的ReactiveESTemplate在注入后并不意味着结束，还会有映射问题，因返回高亮结果不能和 pojo 自动映射，故还需自行扩展 DefaultResultMapper（）修改映射12345678910111213141516171819202122232425262728293031323334353637383940414243@Configuration(proxyBeanMethods = false)class ReactiveESTemplateConfiguration() &#123; @Bean fun reactiveElasticsearchTemplate(client: ReactiveElasticsearchClient?, converter: ElasticsearchConverter?): CustomReactiveESTemplate? &#123; //处理高亮字段映射 val resultsMapper = object : DefaultResultMapper() &#123; override fun &lt;T : Any?&gt; mapSearchHit(searchHit: SearchHit?, type: Class&lt;T&gt;?): T? &#123; if (!searchHit!!.hasSource()) return null val source = searchHit.sourceAsMap if (!source.containsKey(\"id\") || source[\"id\"] == null) source[\"id\"] = searchHit.id val highlightFields = searchHit.highlightFields // fragments 因所写项目功能单一故处理不是很恰当 // 将原本与高亮域对应的原生字段替换为高亮后的结果 source[\"q\"] = highlightFields.get(\"q\") ?.fragments ?.get(0)?.toString() ?: source[\"a\"] source[\"a\"] = highlightFields.get(\"a\") ?.fragments ?.get(0)?.toString() ?: source[\"a\"] // 映射到 pojo val mappedResult: Any = entityMapper.readObject(source, type) as Any return if (type!!.isInterface) projectionFactory.createProjection(type, mappedResult) else type.cast(mappedResult) &#125; &#125; //注入构造参数 val template = CustomReactiveESTemplate(client, converter, resultsMapper) template.setIndicesOptions(IndicesOptions.strictExpandOpenAndForbidClosed()) template.setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE) return template &#125;&#125;3. 在 WebFlux 调用查询1234567891011121314151617181920212223242526272829303132333435@Componentclass ItemsESRepository &#123; @Autowired private lateinit var customReactiveESTemplate: CustomReactiveESTemplate /** * 分页 */ private val pageRequest = PageRequest.of(0, 5) /** * 最少搜索输入字符长度 */ private val minSearchLength = 5 /** * 通过问题和选项搜索 */ suspend fun searchByQuestionAndOptions(questions: String): Flux&lt;TestEntity&gt; &#123; /* if (questions.length &lt; minSearchLength) return Flux.empty()*/ val boolBuilder = QueryBuilders.boolQuery() //多个字段匹配 属性值 must query val matchQueryBuilder = QueryBuilders.multiMatchQuery(questions, \"q\", \"a\") boolBuilder.must(matchQueryBuilder) val query = NativeSearchQueryBuilder() .withQuery(boolBuilder) .withPageable(pageRequest) .build() query.preference = \"q#a\" return customReactiveESTemplate .find(query, TestEntity::class.java) &#125;&#125;结语至此，在webflux 中进行es的高亮多字段查询完成对了 SpringBoot 版本为 2.2.6.RELEASE, ES 版本为6.8Spring WebFlux 目前生态算不上太好，总的来说Rective还是大势所趋的，期待loom的早日完工","categories":[{"name":"后端","slug":"后端","permalink":"https://tuchg.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://tuchg.github.io/tags/kotlin/"},{"name":"协程","slug":"协程","permalink":"https://tuchg.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://tuchg.github.io/tags/ElasticSearch/"},{"name":"webflux","slug":"webflux","permalink":"https://tuchg.github.io/tags/webflux/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"https://tuchg.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Vert.x","slug":"Vert-x","permalink":"https://tuchg.github.io/tags/Vert-x/"},{"name":"kotlin","slug":"kotlin","permalink":"https://tuchg.github.io/tags/kotlin/"},{"name":"协程","slug":"协程","permalink":"https://tuchg.github.io/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://tuchg.github.io/tags/ElasticSearch/"},{"name":"webflux","slug":"webflux","permalink":"https://tuchg.github.io/tags/webflux/"}]}